---
title: "从零实现一个 Java 微框架 - IoC"
date: 2021-04-11
categories:
  - 折腾记录
tags:
  - Java
  - XK-Java
  - 框架
---

## 前言

IoC 容器再之前的文章中就有说明。

<post link={"/post/talking-about-di-and-ioc"} />

之前的文章其实是基于 PHP 的，虽然思想是类似的，不过还是再次说明一下吧。

## IoC 是什么？

**IoC（Inversion of control，控制反转）**，它是一种思想而不是一个技术实现（组件），通常也和 DI（Dependency Injection，依赖注入）一同出现，这两者其实可以看成一个东西。不过 DI 更多的是指注入的过程或方式（B 对象注入到了 A），IoC 更多的是指这种反转思想（B 对象交给了外部管理）。

为了更好的描述 IoC，这里我们就引入一个样例吧，就拿我前几天购买的一个阅读器来说吧。既然是阅读器，那么我们肯定是要有个阅读器的类：

```java
public class BookReader {

    private final BookStorage storage;

    public BookReader() {
        this.storage = new FileBookStorage();
    }

    public String read(final String name) {
        return this.storage.getBook(name).getContent();
    }

    public void put(final Book book) {
        this.storage.registerBook(book);
    }
}
```

其中，我们需要一个 `BookStorage` 来存储阅读器里存放的书，然后阅读器拥有 `read` 阅读和 `put` 存新书的功能。

通常情况下我们会将所依赖的 `BookStorage` 的对象直接在构造器中 `new` 出来，这是最简单且直接的使用方式。但是这种简单的方式也导致了一种问题，如果哪天需要开发一个基于网络的阅读器，那么我们的存储不再是 `FileBookStorage`，而应该是 `NetworkBookStorage`，此时为了能制作出网络阅读器我们就不得不重新写一个 `BookReader` 类，然后重新实现内部的逻辑。

这时候肯定有人会提出应该把 `BookStorage` 从外面通过构造器传入不就可以了？其实当你提出这个疑问的时候你已经可以说了解 IoC 了，这种通过**外部传入依赖**的方式就称为**依赖注入**，也就是**控制反转的思想**。

控制反转中的**控制**指的是对对象管理、创建的权力；**反转**指的是将这个控制权交给外部环境，至于外部环境可以是几行代码、IoC 容器。使用者只负责使用依赖，至于依赖是如何构造、管理的这就不关使用者的事了。

利用 IoC 思想改造后的构造器如下：

```java
public BookReader(final BookStorage bookStorage) {
    this.storage = bookStorage;
}
```

改造后虽然我们丢失了创建 `BookStorage` 的功能，不过相对的这种方式解决了各部件间强耦合的问题，我们可以通过给 `BookReader` 传入不同的 `BookStorage` 来灵活的实现及复用。

## IoC 容器

**IoC 容器（IoC Container）**一般也称为 **IoC 服务提供者（IoC Service Provider）**，简单的说就是用来自动化创建依赖以及管理依赖的工厂。由于经常被简称为 IoC 所以也很多人会认为 IoC 就是 IoC 容器，其实 IoC 容器只是用来方便实现 IoC 思想的一种工具。
