---
title: "从零实现一个 Java 微框架 - IoC"
date: 2021-04-11
categories:
  - 折腾记录
tags:
  - Java
  - XK-Java
  - 框架
---

## 前言

IoC 容器再之前的文章中就有说明。

<post link={"/post/talking-about-di-and-ioc"} />

之前的文章其实是基于 PHP 的，虽然思想是类似的，不过还是再次说明一下吧。

## IoC 是什么？

**IoC（Inversion of control，控制反转）**，它是一种思想而不是一个技术实现（组件），通常也和 DI（Dependency Injection，依赖注入）一同出现，这两者其实可以看成一个东西。不过 DI 更多的是指注入的过程或方式（B 对象注入到了 A），IoC 更多的是指这种反转思想（B 对象交给了外部管理）。

为了更好的描述 IoC，这里我们就引入一个样例吧，就拿我前几天购买的一个阅读器来说吧。既然是阅读器，那么我们肯定是要有个阅读器的类：

```java
public class BookReader {

    private final BookStorage storage;

    public BookReader() {
        this.storage = new FileBookStorage();
    }

    public String read(final String name) {
        return this.storage.getBook(name).getContent();
    }

    public void put(final Book book) {
        this.storage.registerBook(book);
    }
}
```

其中，我们需要一个 `BookStorage` 来存储阅读器里存放的书，然后阅读器拥有 `read` 阅读和 `put` 存新书的功能。

通常情况下我们会将所依赖的 `BookStorage` 的对象直接在构造器中 `new` 出来，这是最简单且直接的使用方式。但是这种简单的方式也导致了一种问题，如果哪天需要开发一个基于网络的阅读器，那么我们的存储不再是 `FileBookStorage`，而应该是 `NetworkBookStorage`，此时为了能制作出网络阅读器我们就不得不重新写一个 `BookReader` 类，然后重新实现内部的逻辑。

这时候肯定有人会提出应该把 `BookStorage` 从外面通过构造器传入不就可以了？其实当你提出这个疑问的时候你已经可以说了解 IoC 了，这种通过**外部传入依赖**的方式就称为**依赖注入**，也就是**控制反转的思想**。

控制反转中的**控制**指的是对对象管理、创建的权力；**反转**指的是将这个控制权交给外部环境，至于外部环境可以是几行代码、IoC 容器。使用者只负责使用依赖，至于依赖是如何构造、管理的这就不关使用者的事了。

利用 IoC 思想改造后的构造器如下：

```java
public BookReader(final BookStorage bookStorage) {
    this.storage = bookStorage;
}
```

改造后虽然我们丢失了创建 `BookStorage` 的功能，不过相对的这种方式解决了各部件间强耦合的问题，我们可以通过给 `BookReader` 传入不同的 `BookStorage` 来灵活的实现及复用。

## IoC 容器

**IoC 容器（IoC Container）**一般也称为 **IoC 服务提供者（IoC Service Provider）**，简单的说就是用来自动化创建依赖以及管理依赖的工厂。由于经常被简称为 IoC 所以也很多人会认为 IoC 就是 IoC 容器，其实 IoC 容器只是用来方便实现 IoC 思想的一种工具。

最简单的 IoC 容器包括了以下几种功能：

- 对象的构建管理：当我们需要某个对象的时候无需关心它是如何被创建出来的、需要什么依赖关系，这个过程就是由 IoC 负责的。
- 对象的依赖绑定：为了对对象进行构建，IoC 容器需要知道对象的依赖关系。
- 对象的存储管理：既然是容器那就需要有存储的功能，IoC 容器可以依照需求存储单例对象或依赖（需要存储的依赖不单单是 Bean 对象）。

对于现在的 IoC 容器来说注册对象管理信息一般有以下 3 种：

- 直接编码：即调用注册方法 `regsiter` 将对象注册到 IoC 容器中。
- 配置文件：在 Spring IoC 等容器一般都存在这种配置方式，通过配置文件配置 IoC 容器的对象及依赖关系。
- 元数据：元数据的方式则较为广泛，注解、类型、变量名等等都可以作为元数据来指引 IoC 容器注册和使用对象。

通常情况 IoC 容器有以下几种注入方式：

- 构造器注入
- Setter 方式注入
- 字段注入：字段注入可以归入 Setter 注入，有一定侵入性，是利用反射直接设置字段值的方式。
- 接口注入：接口注入是比较特殊的，带有侵入性，不一定所有 IoC 容器都支持，是通过实现接口方法来取得注入的依赖。

## 设计 IoC 容器

既然已经知道了 IoC 容器需要的功能，那么就可以开始设计我们自己的 IoC 容器了。文章可能会结合一些 Spring 的东西。不过本篇文章主要是写我自己的 Java 框架，所以 Spring 就点到为止了，如需深入的话可以看别的源码解析的文章或者书籍。比如这篇大佬写的[文章](http://www.tianxiaobo.com/2018/05/30/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/)就还不错。

XK-Java IoC 容器的设计较为简单，其设计最初的参考是来自 [Laravel](https://laravel.com/)，不过经过后续不断的重构已经比较类似 Spring IoC 了。

IoC 容器所需要存储的数据：

- 实例元信息（Binding, BeanDefinition）：保存实例的一些信息，如作用域、名称、注解等一系列容器需要使用的信息。
- 实例（Instance, Singleton）：由于有些实例是以单例的状态存储的，所以容器还需要为这些实例提供存储。
- 别名（Alias）：实例可以有别的名称。
- 类型索引（BeanNameByType）：通常情况下我们都不会对每个 Bean 都进行配置，所以 IoC 容器一般是使用类型来进行自动注入的，为了能快速的查询到指定类型的依赖，我们需要对每个绑定到 IoC 容器的依赖都进行类型遍历，然后建立索引。
- 注入器 & Bean 处理器（Injector & BeanProcessor）：为了方便扩展和实现额外的功能就不能把构建的流程封闭到 IoC 容器，所以需要通过注入器或者 Bean 处理器来处理实例或依赖。
- 作用域（Context, Scope）：IoC 容器不可能只存储某个作用域的实例，通常有多种作用域，比如单例域、非单例、请求域等多种作用域来存储实例。
- 临时依赖（DataBinder）：由于部分情况需要临时注入一些依赖，比如 HTTP 的请求参数，这就需要有一个数据容器来临时存储这些参数依赖。

XK-Java IoC 容器所需要的功能：

- 绑定：用于将依赖绑定到容器中，依赖可以是已经构建完成的实例、立即值、工厂类等等。对应 `bind`、`doBind` 方法。
- 构建：当某个依赖被依赖的时候，而且依赖没有构建的时候就需要对依赖进行构建。对应 `doBuild` 方法。
- 获取：当我们需要某个实例的时候，就需要从 IoC 容器获取。对应 `make`、`doMake` 方法。
- 销毁：当依赖被从容器删除，或者容器关闭的时候就需要对依赖进行销毁操作，如关闭连接池等等的操作。对应 `remove`、`doRemove` 方法。

## 实现

有了大致的设计我们就可以开始动工了。

首先需要准备一些周边的类和接口，以下这些周边类是属于 IoC 的一部分，有些其他的类，如 [MergedAnnotation](/post/talking-about-merged-annotation)，就不在这里说明了。

- [TypeProvider](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/type/TypeProvider.java)：为实现集合、Map 等复合类型注入的类型提供器。因为 Java 有泛型擦除的问题，无法简单的保留泛型，需要从 `Field` 等类中读取然后保存传递到容器中。
- [TypeWrapper](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/type/TypeWrapper.java)：TypeProvider 的实现类。
- [FactoryBean](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/factory/FactoryBean.java)：工厂 Bean，作用和 Spring 的类似，用于创建 Bean 的工厂。
- [ObjectFactory](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/factory/ObjectFactory.java)：作用和 Spring 类似，用于延迟获取 Bean，不过在本框架也用于 Cglib 代理。
- [ObjectProvider](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/factory/ObjectProvider.java)：作用和 Spring 类似，相当于高级的 ObjectFactory。
- [AnnotatedEntry](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/entity/AnnotatedEntry.java)、[ClassProperty](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/entity/ClassProperty.java)、[ConstructorContext](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/entity/ConstructorContext.java)、[InjectContext](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/entity/InjectContext.java)、[ParameterContext](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/entity/ParameterContext.java)：一些包装类。
- [ScopeType](https://github.com/syfxlin/xkjava/blob/ce06902e7b8b6650791c41aa0ce13c291b311969/xkjava-framework/src/main/java/me/ixk/framework/ioc/context/ScopeType.java)：就一个静态类，存放内置作用域名称的常量。

有了上面这些周边类，就可以进入下一部分了。

### DataBinder

由于 XK-Java 的设计与 Spring 有所不同。在 XK-Java 的设计里，所有需要注入的（如注入单例，注入请求参数） Java 实例都应该由 IoC 容器负责构建。通常情况下我们有可能会临时设置一些依赖，而又不希望这些临时的依赖托管到容器里，这时候就需要 DataBinder 来负责存储。

```java
// see: https://github.com/syfxlin/xkjava/blob/36b1ca22c86790b93e79a00c5b6c3e031ad6139b/xkjava-framework/src/main/java/me/ixk/framework/ioc/binder/DataBinder.java
public interface DataBinder {
    /**
     * 获取实例
     *
     * @param name       实例名
     * @param type       实例类型
     * @param annotation 注解
     * @param <T>        实例类型
     * @param container  容器
     * @return 实例
     */
    <T> T getObject(
        String name,
        TypeWrapper<T> type,
        MergedAnnotation annotation,
        Container container
    );
}

```

DataBinder 被设计为简单的依赖存储容器，所以无需非常多的元信息，通过实例的名称、类型、注解即可取得其存储的实例。可以认为是缩小版的 IoC 容器。

DefaultDataBinder 是默认的实现类：

```java
// see: https://github.com/syfxlin/xkjava/blob/36b1ca22c86790b93e79a00c5b6c3e031ad6139b/xkjava-framework/src/main/java/me/ixk/framework/ioc/binder/DefaultDataBinder.java
public class DefaultDataBinder implements DataBinder {
    // 实例容器 <名称，实例>
    private final Map<String, Object> objects = new HashMap<>();
    // 类型对应的实例名称 <类型，<名称>>
    private final Map<Class<?>, List<String>> objectTypes = new HashMap<>();

    @Override
    public <T> T getObject(
        String name,
        final TypeWrapper<T> type,
        final MergedAnnotation annotation,
        final Container container
    ) {
        // 取得 DataBind 注解，DataBind 注解可以控制注入的实例
        final DataBind dataBind = annotation == null
            ? null
            : annotation.getAnnotation(DataBind.class);
        if (dataBind != null && dataBind.name().length() != 0) {
            // 如果 DataBind 设置要取得的实例的名称就以 DataBind 为准
            name = dataBind.name();
        }
        final Class<T> clazz = type.getClazz();
        // 取得对应名称的实例
        Object object = this.objects.get(name);
        // 如果取得的实例类型不符，那就放弃这个实例（需要注意，DataBind 被设计为不允许类型转换）
        if (object != null && !clazz.isInstance(object)) {
            object = null;
        }
        if (object == null) {
            // 如果通过名称找不到就尝试通过类型查找
            final List<String> list = this.objectTypes.get(clazz);
            final String objectName;
            if (list == null || list.isEmpty()) {
                // 如果没找到就使用默认的名称，即类名首字母小写后的名称
                objectName = container.typeToBeanName(clazz);
            } else {
                objectName = list.get(0);
            }
            object = this.objects.get(objectName);
        }
        if (object == null) {
            // 如果还是没取得，就尝试使用 IoC 容器构建（递归构建）
            object = container.make(name, type, this);
        }
        if (
            object == null &&
            dataBind != null &&
            DataBind.EMPTY.equals(dataBind.defaultValue())
        ) {
            // 构建还是失败了（真惨），那就使用 DataBind 设置的默认值
            object = dataBind.defaultValue();
        }
        // 类型转换（需要注意，这只是简单的转换）
        return Convert.convert(clazz, object);
    }
}
```

### Context

Context 类似于 Spring 的 Scope，用于作用域隔离，比如线程私有实例，请求私有实例等等。具体的可以参考 Spring 的 Scope 的作用。

```java
// see: https://github.com/syfxlin/xkjava/blob/36b1ca22c86790b93e79a00c5b6c3e031ad6139b/xkjava-framework/src/main/java/me/ixk/framework/ioc/context/Context.java
public interface Context {
    /**
     * 是否是共享的，即单例
     *
     * @return 是否
     */
    default boolean isShared() {
        return true;
    }

    /**
     * 该 Context 是否启动，一般的 Context 只要 new 后就会启动 但是如果是 ThreadLocal 则需要另行启动
     *
     * @return 是否启动
     */
    default boolean isCreated() {
        return true;
    }

    /**
     * 是否需要代理
     *
     * @return 是否需要代理
     */
    default boolean useProxy() {
        return false;
    }

    /**
     * 获取所有实例
     *
     * @return 所有实例
     */
    ConcurrentMap<String, Object> getInstances();

    /**
     * 获取实例
     *
     * @param name 实例名称
     * @return 实例
     */
    default Object get(final String name) {
        return this.getInstances().get(name);
    }

    /**
     * 删除实例
     *
     * @param name 实例名称
     */
    default void remove(final String name) {
        this.getInstances().remove(name);
    }

    /**
     * 设置实例
     *
     * @param name     名称
     * @param instance 实例
     */
    default void set(final String name, final Object instance) {
        this.getInstances().put(name, instance);
    }

    /**
     * 是否存在实例
     *
     * @param name 实例名称
     * @return 是否存在
     */
    default boolean has(final String name) {
        return this.getInstances().containsKey(name);
    }
}
```

可以看到 Context 其实就是一个类似 Map 的容器，只不过有些其他的方法：

- `isShared` 方法用于确定是否是单例，如果是单例 IoC 容器会在构建实例完后将单例存入 Context。
- `isCreated` 方法用于确定实例是否启动，避免在未启动的时候错误使用。
- `useProxy` 方法用于确定实例是否需要 Cglib 代理来实时获取最新的值，避免发生使用旧对象情况，或者将 Request 作用域对象注入到 Singleton 作用域导致线程不安全。

有了接口自然有实现类，以下是几个不同场景的实现类：

- [SingletonContext](https://github.com/syfxlin/xkjava/blob/36b1ca22c86790b93e79a00c5b6c3e031ad6139b/xkjava-framework/src/main/java/me/ixk/framework/ioc/context/SingletonContext.java)：单例作用域，里面就是一个简单的 ConcurrentHashMap。
- [PrototypeContext](https://github.com/syfxlin/xkjava/blob/36b1ca22c86790b93e79a00c5b6c3e031ad6139b/xkjava-framework/src/main/java/me/ixk/framework/ioc/context/PrototypeContext.java)：原型作用域，不存储实例，是非共享的。
- [RequestContext](https://github.com/syfxlin/xkjava/blob/36b1ca22c86790b93e79a00c5b6c3e031ad6139b/xkjava-framework/src/main/java/me/ixk/framework/ioc/context/RequestContext.java)：请求作用域，这个作用域和 [SessionContext](https://github.com/syfxlin/xkjava/blob/36b1ca22c86790b93e79a00c5b6c3e031ad6139b/xkjava-framework/src/main/java/me/ixk/framework/ioc/context/SessionContext.java) 一样比较特殊，是存储于对应作用域的对象里，比如 Request 是存储于 HttpServletRequest 的 Attribute 里，Session 则存储于 HttpSession 里。
